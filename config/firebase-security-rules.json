{
  // Global read/write Firebase rules for quick paste
  // DO NOT UNCOMMENT. Just for pasting into firebase gui when uploading test data { "rules": { ".read": true, ".write": true } }
  // Production rules follow...

  "rules": {
    "authentication": {
      "$uid": {
        // create, but not modify or delete, for any authenticated user's own authentication
        ".write": "!data.exists() && newData.exists() && $uid === auth.uid",
        // user must have email, and at least one of business_id and spinner_id (and possibly both)
        ".validate": "newData.child('email').exists() && (newData.child('business_id').exists() || newData.child('spinner_id').exists())",

        "business_id": {
          ".validate": "root.child('businesses/'+newData.val()).exists()" // TODO - nothing prevents two users from pointing to the same business, ie a new user snagging a business
        },

        "spinner_id": {
          ".validate": "root.child('spinners/'+newData.val()).exists()" // TODO - nothing prevents two users from pointing to the same spinner, ie a new user snagging a spinner
        },

        "email": {
          ".validate": "newData.val() === auth.email"
        },

        "$other": { ".validate": false }
      }
    },

    "businesses": {
      ".read": "auth !== null",

      "$business_id": {
        // create, but not update or delete, for any authenticated user
        ".write": "!data.exists() && root.child('authentication/'+auth.uid).exists()",
        ".validate": "newData.hasChildren(['name', 'address'])",

        "name": {
          // This rule will allow a user to save() their Business model in Ember, without actually permitting changes to name
          ".write": "data.exists() && newData.val() === data.val() && $business_id === root.child('authentication/'+auth.uid+'/business_id').val()",
          ".validate": "newData.isString() && newData.val().length > 0 && newData.val().length < 45"
        },

        "address": {
          // This rule will allow a user to save() their Business model in Ember, without actually permitting changes to address
          ".write": "data.exists() && newData.val() === data.val() && $business_id === root.child('authentication/'+auth.uid+'/business_id').val()",
          ".validate": "newData.isString() && newData.val().length > 0 && newData.val().length < 100"
        },

        "spinnerShifts": {
          "$spinner_shift_id": {
            // create, but not update or delete, for this user's business
            ".write": "!data.exists() && newData.exists() && $business_id === root.child('authentication/'+auth.uid+'/business_id').val() && root.child('spinnerShifts/'+$spinner_shift_id).exists()",
            ".validate": "newData.isBoolean()"
          }
        },

        "$other": { ".validate": false }
      }
    },

    "spinnerShifts": {
      ".read": "auth !== null",

      "$spinner_shift_id": {
        // Business updates to this SpinnerShift
        // 1. create, but not update or delete, if the user owns this business
        // 2. delete if the user owns this business, and this business isn't associated with this spinnerShift, ie a dangling reference that needs to be cleaned up
        //
        // OR
        //
        // Spinner may update a SpinnerShift if all of these are true
        // 1. old state is unmatched
        // 2. new state is matched
        // 3. user is a spinner
        // 4. new spinner is user
        // 5. business, startDateAndTime, endDateAndTime are not modified. 
        // 6. spinnerRating doesn't exist
        //
        // OR
        //
        // Business may cancel an unmatched shift if all these are true
        // 1. old state is unmatched
        // 2. new state is cancelled
        // 3. user owns this business
        // 4. business is not modified
        // 4* technically I should check for everything else. Spinner doesn't exist, rating doesn't exist, business doesn't change.
        //    This is more than a little ridiculous, I need to find a way to simplify these rules.
        //
        // OR
        //
        // Business may set spinnerRating if all these are true
        // 1. old state is matched
        // 2. new state is completed
        // 3. user owns this business
        // 4. old spinnerRating doesn't exist
        // 5. new spinnerRating does exist
        // 6. nothing else is modified
        //    This rule is totally fucking ridiculous. REFACTOR
        ".write": "((!data.exists() && newData.exists() && newData.child('business').val() === root.child('authentication/'+auth.uid+'/business_id').val()) ||
                   (data.exists() && !newData.exists() && data.child('business').val() === root.child('authentication/'+auth.uid+'/business_id').val() &&
                      !root.child('businesses/'+data.child('business').val()+'/spinnerShifts/'+$spinner_shift_id).exists()))
                                              ||
                                        (data.child('state').val() === 'unmatched' &&
                                         newData.child('state').isString() && 
                                         newData.child('state').val() === 'matched' &&
                                         root.child('authentication/'+auth.uid+'/spinner_id').exists() &&
                                         newData.child('spinner').val() === root.child('authentication/'+auth.uid+'/spinner_id').val() &&
                                         data.child('startDateAndTime').val() === newData.child('startDateAndTime').val() &&
                                         data.child('endDateAndTime').val()   === newData.child('endDateAndTime').val() &&
                                         data.child('business').val()         === newData.child('business').val() &&
                                         !newData.child('spinnerRating').exists())
                                              ||
                                        (data.child('state').val() === 'unmatched' &&
                                         newData.child('state').isString() &&
                                         newData.child('state').val() === 'cancelled' &&
                                         data.child('business').val() === root.child('authentication/'+auth.uid+'/business_id').val() &&
                                         data.child('business').val() === newData.child('business').val())
                                              ||
                                        (data.child('state').val()    === 'matched' &&
                                         newData.child('state').isString() &&
                                         newData.child('state').val() === 'completed' &&
                                         data.child('business').val() === root.child('authentication/'+auth.uid+'/business_id').val() &&
                                         !data.child('spinnerRating').exists() &&
                                         newData.child('spinnerRating').exists() &&
                                         data.child('startDateAndTime').val() === newData.child('startDateAndTime').val() &&
                                         data.child('endDateAndTime').val()   === newData.child('endDateAndTime').val() &&
                                         data.child('business').val()         === newData.child('business').val() &&
                                         data.child('spinner').val()          === newData.child('spinner').val())",
        ".validate": "newData.hasChildren(['business', 'startDateAndTime', 'endDateAndTime', 'state'])",

        "business": {
          ".validate": "root.child('businesses/'+newData.val()).exists()"
        },

        "startDateAndTime": {
          ".validate": "newData.isString() && newData.val().length > 0" // TBD - validate it's a date && start < end
        },

        "endDateAndTime": {
          ".validate": "newData.isString() && newData.val().length > 0" // TBD - validate it's a date && start < end
        },

        "state": {
          ".validate": "newData.isString() && (newData.val() === 'unmatched' ||
                                               newData.val() === 'matched'   ||
                                               newData.val() === 'completed' ||
                                               newData.val() === 'cancelled' ||
                                               newData.val() === 'error')" // TBD - validate that matched/completed have a spinner; cancelled/unmatched has no spinner;
                                                                          //        validate that each state transition is legal, ie you can't go from unmatched to completed.
        },

        "spinner": {
          ".validate": "root.child('spinners/'+newData.val()).exists()"
        },

        "spinnerRating": {
          ".validate": "newData.isNumber() && (newData.val() === 1 ||
                                               newData.val() === 2 ||
                                               newData.val() === 3 ||
                                               newData.val() === 4 ||
                                               newData.val() === 5)"
        },

        "errorReason": {
          ".validate": "newData.isString()"
        },

        "$other": { ".validate": false }
      }
    },

    "spinners": {
      ".read": "auth !== null",

      "$spinner_id": {
        // create, but not update or delete, for any authenticated user
        ".write": "!data.exists() && root.child('authentication/'+auth.uid).exists()",
        ".validate": "newData.hasChildren(['firstName', 'lastName'])",

        "firstName": {
          // This rule will allow a user to save() their Spinner model in Ember, without actually permitting changes to firstName
          ".write": "data.exists() && newData.val() === data.val() && $spinner_id === root.child('authentication/'+auth.uid+'/spinner_id').val()",
          ".validate": "newData.isString() && newData.val().length > 0 && newData.val().length < 45"
        },

        "lastName": {
          // This rule will allow a user to save() their Spinner model in Ember, without actually permitting changes to lastName
          ".write": "data.exists() && newData.val() === data.val() && $spinner_id === root.child('authentication/'+auth.uid+'/spinner_id').val()",
          ".validate": "newData.isString() && newData.val().length > 0 && newData.val().length < 45"
        },

        "spinnerShifts": {
          "$spinner_shift_id": {
            // create, but not update or delete, for this user's spinner
            ".write": "!data.exists() && newData.exists() && $spinner_id === root.child('authentication/'+auth.uid+'/spinner_id').val() && root.child('spinnerShifts/'+$spinner_shift_id).exists()",
            ".validate": "newData.isBoolean()"
          }
        },

        "$other": { ".validate": false }
      }
    },

    "$other": { ".validate": false }
  }
}
