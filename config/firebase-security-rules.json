{
  // Global read/write Firebase rules for quick paste
  // DO NOT UNCOMMENT. Just for pasting into firebase gui when uploading test data { "rules": { ".read": true, ".write": true } }
  // Production rules follow...

  "rules": {
    "authentication": {
      // owned_{businesses,spinners} lists the {businesses,spinners} which are associated with an authentication. This prevents two users from pointing to the same business/spinner.
      // This data must be set simultaneously with authentication/users/$uid/business_id - they do mutual validation
      //   Note that the simultaneous update requirement can be removed by setting owned_businesses/$business_id before users/$uid is created.
      //   However, although this simplifies validation, it creates an unhappy rollback scenario whereby if users/$uid fails to create, we now have a dangling
      //   reference in owned_businesses/$business_id. With simultaneous updates, authentication is set atomically.
      // create, but not update or delete, when the {business,spinner}_id exists and the users auth specifies that id
      "owned_businesses": {
        "$business_id": {
          // create, but not update or delete
          // business_id should
          //   be a valid business_id
          //   be set simultaneously in authentication/users/$uid/business_id
          ".write": "auth !== null &&
                     !data.exists() &&
                     newData.exists() &&
                     root.child('businesses/'+$business_id).exists() &&
                     newData.parent().parent().child('users/'+auth.uid+'/business_id').val() === $business_id",
          // value set to auth.uid which is simultaneously validated in users/$uid/business_id
          ".validate": "newData.val() === auth.uid"
        }
      },

      // See comment on owned_businesses
      "owned_spinners": {
        "$spinner_id": {
          // create, but not update or delete
          // spinner_id should
          //   be a valid spinner_id
          //   be set simultaneously in authentication/users/$uid/spinner_id
          ".write": "auth !== null &&
                     !data.exists() &&
                     newData.exists() &&
                     root.child('spinners/'+$spinner_id).exists() &&
                     newData.parent().parent().child('users/'+auth.uid+'/spinner_id').val() === $spinner_id",
          // value set to auth.uid which is simultaneously validated in users/$uid/spinner_id
          ".validate": "newData.val() === auth.uid"
        }
      },

      "users": {
        "$uid": {
          ".read": "$uid === auth.uid",
          // create, but not modify or delete, for any authenticated user's own authentication
          ".write": "!data.exists() && newData.exists() && $uid === auth.uid",
          // user must have email, and at least one of business_id and spinner_id (and possibly both)
          ".validate": "newData.child('email').exists() && (newData.child('business_id').exists() || newData.child('spinner_id').exists())",

          "business_id": {
            // business_id should
            //   be a valid business_id
            //   not yet exist in authentication/owned_businesses
            //   be set in authentication/owned_businesses simultaneously
            ".validate": "root.child('businesses/'+newData.val()).exists() &&
                          !root.child('authentication/owned_businesses/'+newData.val()).exists() &&
                          newData.parent().parent().parent().child('owned_businesses/'+newData.val()).val() === auth.uid"
          },

          "spinner_id": {
            // spinner_id should
            //   be a valid spinner_id
            //   not yet exist in authentication/owned_spinners
            //   be set in authentication/owned_spinners simultaneously
            ".validate": "root.child('spinners/'+newData.val()).exists() &&
                          !root.child('authentication/owned_spinners/'+newData.val()).exists() &&
                          newData.parent().parent().parent().child('owned_spinners/'+newData.val()).val() === auth.uid"
          },

          "email": {
            ".validate": "newData.val() === auth.email"
          },

          "$other": { ".validate": false }
        }
      }
    },

    "businesses": {
      ".read": "auth !== null",

      "$business_id": {
        // create, but not update or delete, for any authenticated user
        ".write": "!data.exists() && root.child('authentication/users/'+auth.uid).exists()",
        ".validate": "newData.hasChildren(['name', 'address'])",

        "name": {
          // This rule will allow a user to save() their Business model in Ember, without actually permitting changes to name
          ".write": "data.exists() && newData.val() === data.val() && $business_id === root.child('authentication/users/'+auth.uid+'/business_id').val()",
          ".validate": "newData.isString() && newData.val().length > 0 && newData.val().length < 45"
        },

        "address": {
          // This rule will allow a user to save() their Business model in Ember, without actually permitting changes to address
          ".write": "data.exists() && newData.val() === data.val() && $business_id === root.child('authentication/users/'+auth.uid+'/business_id').val()",
          ".validate": "newData.isString() && newData.val().length > 0 && newData.val().length < 100"
        },

        "spinnerShifts": {
          "$spinner_shift_id": {
            // create, but not update or delete, for this user's business
            ".write": "!data.exists() && newData.exists() && $business_id === root.child('authentication/users/'+auth.uid+'/business_id').val() && root.child('spinnerShifts/'+$spinner_shift_id).exists()",
            ".validate": "newData.isBoolean()"
          }
        },

        "$other": { ".validate": false }
      }
    },

    "spinnerShifts": {
      ".read": "auth !== null",

      "$spinner_shift_id": {
        // Business updates to this SpinnerShift
        // 1. create, but not update or delete, if the user owns this business
        // 2. delete if the user owns this business, and this business isn't associated with this spinnerShift, ie a dangling reference that needs to be cleaned up
        //
        // OR
        //
        // Spinner may update a SpinnerShift if all of these are true
        // 1. old state is unmatched
        // 2. new state is matched
        // 3. user is a spinner
        // 4. new spinner is user
        // 5. business, startDateAndTime, endDateAndTime are not modified. 
        // 6. spinnerRating doesn't exist
        //
        // OR
        //
        // Business may cancel an unmatched shift if all these are true
        // 1. old state is unmatched
        // 2. new state is cancelled
        // 3. user owns this business
        // 4. business is not modified
        // 4* technically I should check for everything else. Spinner doesn't exist, rating doesn't exist, business doesn't change.
        //    This is more than a little ridiculous, I need to find a way to simplify these rules.
        //
        // OR
        //
        // Business may set spinnerRating if all these are true
        // 1. old state is matched
        // 2. new state is completed
        // 3. user owns this business
        // 4. old spinnerRating doesn't exist
        // 5. new spinnerRating does exist
        // 6. nothing else is modified
        //    This rule is totally fucking ridiculous. REFACTOR
        ".write": "((!data.exists() && newData.exists() && newData.child('business').val() === root.child('authentication/users/'+auth.uid+'/business_id').val()) ||
                   (data.exists() && !newData.exists() && data.child('business').val() === root.child('authentication/users/'+auth.uid+'/business_id').val() &&
                      !root.child('businesses/'+data.child('business').val()+'/spinnerShifts/'+$spinner_shift_id).exists()))
                                              ||
                                        (data.child('state').val() === 'unmatched' &&
                                         newData.child('state').isString() && 
                                         newData.child('state').val() === 'matched' &&
                                         root.child('authentication/users/'+auth.uid+'/spinner_id').exists() &&
                                         newData.child('spinner').val() === root.child('authentication/users/'+auth.uid+'/spinner_id').val() &&
                                         data.child('startDateAndTime').val() === newData.child('startDateAndTime').val() &&
                                         data.child('endDateAndTime').val()   === newData.child('endDateAndTime').val() &&
                                         data.child('business').val()         === newData.child('business').val() &&
                                         !newData.child('spinnerRating').exists())
                                              ||
                                        (data.child('state').val() === 'unmatched' &&
                                         newData.child('state').isString() &&
                                         newData.child('state').val() === 'cancelled' &&
                                         data.child('business').val() === root.child('authentication/users/'+auth.uid+'/business_id').val() &&
                                         data.child('business').val() === newData.child('business').val())
                                              ||
                                        (data.child('state').val()    === 'matched' &&
                                         newData.child('state').isString() &&
                                         newData.child('state').val() === 'completed' &&
                                         data.child('business').val() === root.child('authentication/users/'+auth.uid+'/business_id').val() &&
                                         !data.child('spinnerRating').exists() &&
                                         newData.child('spinnerRating').exists() &&
                                         data.child('startDateAndTime').val() === newData.child('startDateAndTime').val() &&
                                         data.child('endDateAndTime').val()   === newData.child('endDateAndTime').val() &&
                                         data.child('business').val()         === newData.child('business').val() &&
                                         data.child('spinner').val()          === newData.child('spinner').val())",
        ".validate": "newData.hasChildren(['business', 'startDateAndTime', 'endDateAndTime', 'state'])",

        "business": {
          ".validate": "root.child('businesses/'+newData.val()).exists()"
        },

        "startDateAndTime": {
          ".validate": "newData.isString() && newData.val().length > 0" // TBD - validate it's a date && start < end
        },

        "endDateAndTime": {
          ".validate": "newData.isString() && newData.val().length > 0" // TBD - validate it's a date && start < end
        },

        "state": {
          ".validate": "newData.isString() && (newData.val() === 'unmatched' ||
                                               newData.val() === 'matched'   ||
                                               newData.val() === 'completed' ||
                                               newData.val() === 'cancelled' ||
                                               newData.val() === 'error')" // TBD - validate that matched/completed have a spinner; cancelled/unmatched has no spinner;
                                                                          //        validate that each state transition is legal, ie you can't go from unmatched to completed.
        },

        "spinner": {
          ".validate": "root.child('spinners/'+newData.val()).exists()"
        },

        "spinnerRating": {
          ".validate": "newData.isNumber() && (newData.val() === 1 ||
                                               newData.val() === 2 ||
                                               newData.val() === 3 ||
                                               newData.val() === 4 ||
                                               newData.val() === 5)"
        },

        "errorReason": {
          ".validate": "newData.isString()"
        },

        "$other": { ".validate": false }
      }
    },

    "spinners": {
      ".read": "auth !== null",

      "$spinner_id": {
        // create, but not update or delete, for any authenticated user
        ".write": "!data.exists() && root.child('authentication/users/'+auth.uid).exists()",
        ".validate": "newData.hasChildren(['firstName', 'lastName'])",

        "firstName": {
          // This rule will allow a user to save() their Spinner model in Ember, without actually permitting changes to firstName
          ".write": "data.exists() && newData.val() === data.val() && $spinner_id === root.child('authentication/users/'+auth.uid+'/spinner_id').val()",
          ".validate": "newData.isString() && newData.val().length > 0 && newData.val().length < 45"
        },

        "lastName": {
          // This rule will allow a user to save() their Spinner model in Ember, without actually permitting changes to lastName
          ".write": "data.exists() && newData.val() === data.val() && $spinner_id === root.child('authentication/users/'+auth.uid+'/spinner_id').val()",
          ".validate": "newData.isString() && newData.val().length > 0 && newData.val().length < 45"
        },

        "spinnerShifts": {
          "$spinner_shift_id": {
            // create, but not update or delete, for this user's spinner
            ".write": "!data.exists() && newData.exists() && $spinner_id === root.child('authentication/users/'+auth.uid+'/spinner_id').val() && root.child('spinnerShifts/'+$spinner_shift_id).exists()",
            ".validate": "newData.isBoolean()"
          }
        },

        "$other": { ".validate": false }
      }
    },

    "errors": {
      "$error_id": {
        // errors are write-once by anyone
        ".write": "!data.exists()",
        ".validate": "newData.hasChildren(['timestamp','stack','otherInformation'])",

        "timestamp": {
          ".validate": "newData.val() <= now"
        },

        "stack": {
          ".validate": "newData.isString()"
        },

        "otherInformation": {
          ".validate": "newData.isString()"
        },

        "$other": { ".validate": false }
      }
    },

    "$other": { ".validate": false }
  }
}
